## JDK Dynamic Proxy + Socket RPC

#### Objective:

This branch implements a basic Remote Procedure Call (RPC) framework using Java Sockets, without relying on Netty/ZooKeeper/Spring. The project allows clients to send requests to the server and receive responses, abstracting the complexity of communication through proxy objects and a service manager. It aims to provide a basic understanding of the traditional RPC call flow.

------

### Project Structure:

- **`com.xiangli.client`**
    - proxy
        - `IoCClient`: Responsible for communicating with the server using sockets, sending requests, and receiving responses.
        - `ClientProxy`: Acts as a dynamic proxy to intercept method calls and convert them into RPC requests to send to the server.
    - **`TestClient`**: Provides test cases that demonstrate how the client requests services from the server.
- **`com.xiangli.common`**
    - message
        - `RpcRequest`: Represents the request object sent from the client to the server.
        - `RpcResponse`: Represents the response object returned by the server to the client.
    - pojo
        - `User`: A simple user entity class used to demonstrate RPC operations.
    - service
        - `UserService`: Defines the interface for user-related operations.
        - `UserServiceImpl`: Implements `UserService`, providing actual business logic.
- **`com.xiangli.server`**
    - manager
        - `ServiceManager`: Responsible for registering and looking up services, managing all available service instances so the server can find the corresponding service implementations.
    - server
        - impl
            - `SimpleRpcServer`: Implements the core logic of the RPC server, accepting client connections and dispatching requests to the correct service.
            - `ThreadPoolRpcServer`: A version of the server that uses a thread pool to handle multiple client connections concurrently.
        - work
            - `WorkThread`: The thread that handles each client's request.

------

### Development Summary:

1. **Client Development:**
    - Implemented a client (`IoCClient`) that uses Java sockets to communicate with the server.
    - The client sends serialized `RpcRequest` objects and receives `RpcResponse` objects.
    - The `ClientProxy` class captures method calls using dynamic proxy, generates corresponding `RpcRequest` objects, and sends them to the server.
2. **Server Development:**
    - Created `SimpleRpcServer` to handle connection requests from clients.
    - The server listens on a specified port and handles each client's request using `WorkThread`.
    - `WorkThread` reads the `RpcRequest` sent by the client, finds the service and method using reflection, invokes the method, and returns the `RpcResponse` to the client.
    - `ThreadPoolRpcServer` uses a thread pool to handle concurrent requests, improving performance.
3. **Service Management:**
    - `ServiceManager` is responsible for registering and looking up services, mapping service interfaces to their implementations, so the server can invoke the correct implementation based on the service name in the request.
4. **Testing:**
    - The `TestClient` class provides test cases that demonstrate how the client can remotely call `UserServiceImpl` on the server and retrieve results.
    - The `UserService` interface and `UserServiceImpl` implementation in the example simulate user operations, such as querying user information and inserting a new user.

------