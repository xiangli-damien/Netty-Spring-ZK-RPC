# Spring + Netty + ZK + RPC (Version 0.2.2)



### **Overview**

Version 0.2.2 introduces several significant improvements to the Spring + Netty RPC framework, primarily focusing on the customization of serialization and deserialization, as well as encoding and decoding mechanisms. This version enhances the modularity of the project by allowing developers to easily plug in different serialization methods while maintaining a flexible and efficient network communication layer using Netty.

### **Key Features**

- **Custom Serialization & Deserialization**: The framework now supports a pluggable serialization mechanism, where users can choose their preferred serialization format (e.g., JSON, Protostuff). Custom serialization logic can be easily extended.
- **Custom Netty Encoders & Decoders**: New `MyEncoder` and `MyDecoder` classes handle the conversion of objects into byte streams for transmission and back into objects at the receiving end. This improves performance and flexibility by allowing optimized serialization strategies.
- **Improved Error Handling**: More robust exception handling in the encoding/decoding process ensures the framework can gracefully manage errors such as incompatible data types and serialization failures.
- **Spring Integration**: The framework continues to leverage Spring for managing dependencies and RPC service registration, allowing easy configuration and use in Spring-based applications.
- **ZooKeeper for Service Discovery**: Service registration and discovery via ZooKeeper remains a core part of the framework, providing dynamic service location for scalable client-server communication.

### **Project Structure**

1. **Modules**:
   - **rpc-client**: Contains client-side logic, including the dynamic proxy implementation (`RemoteInvokeProxy`) and the Netty client (`NettyRpcClient`). The client now supports customizable serialization formats.
   - **rpc-server**: Contains server-side logic, including service registration and the Netty server (`NettyRpcServer`). Services can handle different serialization formats dynamically based on client requests.
   - **rpc-common**: Contains common components such as the RPC request/response models (`RpcRequest`, `RpcResponse`), and the custom serialization framework (`JsonSerializer`, `ProtostuffSerializer`).
2. **Key Classes**:
   - **MyEncoder & MyDecoder**: Custom classes for encoding and decoding RPC messages, allowing the conversion of request/response objects into byte arrays and vice versa. The decoder also determines the correct serialization strategy based on the incoming message type.
   - **JsonSerializer & ProtostuffSerializer**: Custom serialization classes implementing the `Serializer` interface, responsible for converting Java objects into byte arrays and back. `JsonSerializer` uses JSON-based serialization, while `ProtostuffSerializer` uses binary serialization for more efficient transmission.
   - **NettyRpcClient**: Manages sending RPC requests to the server and handling responses.
   - **NettyRpcServer**: Manages incoming requests from clients, invokes the appropriate service methods, and returns responses.
   - **RpcRequest & RpcResponse**: Define the structure of the communication between client and server, encapsulating method names, parameters, and return values.

### **Improvements Over Version 0.2.1**

- **Customizable Serialization**: Users can now switch between different serialization methods (e.g., JSON, Protostuff) based on their requirements. This modular design improves flexibility and performance.
- **Refined Encoding/Decoding Process**: The encoding and decoding process has been streamlined to handle various types of requests and responses, including the serialization format used. This makes it easier to extend or modify the framework for different communication needs.
- **Enhanced Logging and Error Handling**: The framework now logs detailed information about the encoding/decoding process, making debugging easier. Improved error handling ensures that issues like incompatible types or deserialization failures are handled gracefully.

### **Workflow Overview**

- Service Registration (Server-Side)

  :

  - Services annotated with `@Remote` are automatically registered in the Spring container. The `ZKServiceRegister` registers these services with ZooKeeper, making them available to clients.
  - The `NettyRpcServer` listens on a designated port (e.g., 8181) for incoming requests from clients, using the custom `MyDecoder` to decode requests and the `MyEncoder` to send back responses.

- Service Discovery and Invocation (Client-Side)

  :

  - The client discovers services using `ZKServiceCenter`, which interacts with ZooKeeper to retrieve service information.
  - When a method is invoked on a client-side proxy, the `RemoteInvokeProxy` intercepts the call and sends an `RpcRequest` to the server using the `NettyRpcClient`. The request is serialized using the clientâ€™s chosen `Serializer`.
  - The server processes the request, invokes the corresponding service, and returns an `RpcResponse` to the client. The client deserializes the response using `MyDecoder` and handles the result accordingly.

### **Running the Project**

1. Server

   :

   - Initialize the Spring container and start the server. Services will automatically register with ZooKeeper, and the Netty server will be ready to accept client requests.

2. Client

   :

   - The client initializes its Spring container and retrieves service locations from ZooKeeper. Once the client is ready, it can invoke remote methods using dynamically generated proxies, with requests being handled by the custom Netty client and serialization framework.

### **Sample Workflow**

1. **Client-Side Request**:
   - The `RemoteInvokeProxy` captures a method call on a service interface and packages it into an `RpcRequest` object.
   - The `MyEncoder` serializes this `RpcRequest` into a byte array using the selected serialization method (e.g., JSON).
   - The `NettyRpcClient` sends the serialized request to the server.
2. **Server-Side Processing**:
   - The `NettyRpcServer` receives the byte array and passes it to the `MyDecoder`, which deserializes it into an `RpcRequest` object.
   - The server invokes the requested method and packages the result into an `RpcResponse` object, which is serialized and sent back to the client.
3. **Client-Side Response**:
   - The client receives the `RpcResponse`, which is deserialized by the `MyDecoder` using the appropriate `Serializer`.
   - The result is then returned to the client code, completing the RPC call.