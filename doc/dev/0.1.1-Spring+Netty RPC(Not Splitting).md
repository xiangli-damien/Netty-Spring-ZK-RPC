# Spring + Netty RPC (Version 0.1.1)

## Overview
This version (`0.1.1`) integrates Spring with Netty to create a basic RPC communication framework. The client and server both operate within the same project and use Spring for dependency injection and lifecycle management.

## Key Features
- **Netty Integration**: Netty is used for network communication between the client and server.
- **Spring Framework**: Spring manages the lifecycle of the beans, including the service provider and RPC proxy classes.
- **RPC Communication**: Clients can remotely invoke services using dynamically generated proxies.
- **Log4j Integration**: Basic logging configuration is added with Log4j2 for improved debugging and logging capabilities.
- **Single Project Setup**: This version does not split client and server into separate projects.

## Classes and Structure

### 1. **Netty Components**
- `NettyRpcClient`: Handles sending requests to the server using Netty.
- `NettyRpcServer`: Manages server initialization and listening for incoming RPC requests.
- `NettyClientHandler`: Processes incoming responses from the server.

### 2. **Spring Components**
- `ServiceProvider`: Registers services with the Spring container and provides them when needed.
- `RpcServiceRegistrar`: Automatically registers services annotated with `@Remote` into the Spring context.
- `RemoteInvokeProxy`: Dynamically proxies client-side method invocations and sends them as RPC requests to the server.

### 3. **Common Components**
- `RpcRequest`: Represents the structure of an RPC request.
- `RpcResponse`: Represents the response from the server after processing the RPC request.
- `UserService` / `UserServiceImpl`: Example service to demonstrate the RPC functionality.

## Limitations
- Client and server are still in the same project.
- No service discovery or external registration mechanism (e.g., ZooKeeper) is included.

## Running the Project
1. **Server**: The Netty server will start automatically when the Spring container is initialized.
2. **Client**: The client can invoke services through the `UserController` by sending RPC requests to the server.

## Next Steps
- Split the project into separate client and server modules.
- Integrate a service discovery mechanism (e.g., ZooKeeper).
- Add load balancing and fault tolerance for handling multiple service instances.
